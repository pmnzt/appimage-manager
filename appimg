#!/usr/bin/env bash

# ============================================================
# appimg - AppImage manager tool
# Commands:
#   appimg ls
#   appimg move [--all] [-s dir] [file.AppImage]
#   appimg update
#   appimg setup-all
#   appimg reset
#   appimg select <appname> [--switch <version>]
#   appimg version
#   appimg help
# ============================================================

VERSION="0.1.3"
APPIMG_DIR="$HOME/.appimages"
DESKTOP_TARGET="${XDG_DATA_HOME:-$HOME/.local/share}/applications"

# Ensure ~/.local/share/applications exists
mkdir -p "$DESKTOP_TARGET"


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
die() {
    echo "Error: $1" >&2
    exit 1
}

find_appimages() {
    local search_dir="$1"
    find "$search_dir" -type f -iname "*.AppImage" 2>/dev/null
}

appname_from_path() {
    basename "$1" | sed -E 's/\.AppImage$//i'
}


# ------------------------------------------------------------
# Command: appimg ls
# ------------------------------------------------------------
cmd_ls() {
    local search="$HOME"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            *) die "Unknown option for ls: $1" ;;
        esac
    done

    find_appimages "$search"
}


# ------------------------------------------------------------
# Command: appimg move
# ------------------------------------------------------------
cmd_move() {
    local search="$HOME"
    local do_all=0
    local specific_file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            --all) do_all=1; shift ;;
            *) specific_file="$1"; shift ;;
        esac
    done

    mkdir -p "$APPIMG_DIR"

    # Function to get base name (without .AppImage or .appimage)
    get_base_name() {
        local file="$1"
        local fname
        fname=$(basename "$file")
        fname=$(echo "$fname" | sed -E 's/\.AppImage$//i')
        echo "${fname%%#*}"
    }

    # Function to move icons from tmp associated with a given app
    move_tmp_icons() {
        local app_name="$1"
        local dest="$APPIMG_DIR/$app_name"
        shopt -s nullglob
        for icon in "$APPIMG_DIR/tmp/$app_name-icon."*; do
            [[ -f "$icon" ]] || continue
            ext="${icon##*.}"
            echo "Moving icon $(basename "$icon") → $dest/icon.$ext"
            mv "$icon" "$dest/icon.$ext"
        done
        shopt -u nullglob
    }

    move_one_file() {
        local f="$1"
        # Skip all files inside ~/.appimages except tmp/
        if [[ "$f" == "$APPIMG_DIR"* && "$f" != "$APPIMG_DIR/tmp"* ]]; then
            echo "Skipping (already managed): $f"
            return
        fi

        local filename
        filename=$(basename "$f")
        local name
        name=$(get_base_name "$f")
        local dest="$APPIMG_DIR/$name"
        mkdir -p "$dest"

        shopt -s nullglob
        local versions=("$dest/$name"#*.AppImage)
        shopt -u nullglob

        # If no versioned files exist, check for a single non-versioned AppImage and version it
        if [[ ${#versions[@]} -eq 0 && -f "$dest/$name.AppImage" && ! -L "$dest/$name.AppImage" ]]; then
            echo "Found existing unversioned AppImage for $name. Converting to version #1."
            mv "$dest/$name.AppImage" "$dest/$name#1.AppImage"
            (cd "$dest" && ln -sf "$name#1.AppImage" "$name.AppImage")
            versions=("$dest/$name#1.AppImage") # update versions array
        fi

        local next_version_num=$((${#versions[@]} + 1))
        local new_versioned_filename="$dest/$name#$next_version_num.AppImage"

        echo "Moving $f → $new_versioned_filename"
        mv "$f" "$new_versioned_filename" || die "Failed to move $f"

        local symlink="$dest/$name.AppImage"
        # If no active version symlink exists, create one for the new file
        if [[ ! -e "$symlink" ]]; then
            echo "Setting $(basename "$new_versioned_filename") as active version."
            (cd "$dest" && ln -sf "$(basename "$new_versioned_filename")" "$(basename "$symlink")")
        fi

        # Move associated icons from tmp if they exist
        if [[ "$f" == "$APPIMG_DIR/tmp"* ]]; then
            move_tmp_icons "$name"
        fi
    }

    # Move ALL AppImages
    if [[ "$do_all" -eq 1 ]]; then
        mapfile -t files < <(find_appimages "$search")
        [[ ${#files[@]} -eq 0 ]] && die "No AppImages found."

        for f in "${files[@]}"; do
            move_one_file "$f"
        done
        return
    fi

    # Single file mode
    if [[ -z "$specific_file" ]]; then
        die "You must provide a file unless using --all"
    fi

    # Skip if file is already managed, except tmp
    if [[ "$specific_file" == "$APPIMG_DIR"* && "$specific_file" != "$APPIMG_DIR/tmp"* ]]; then
        echo "Skipping (already in appimages): $specific_file"
        exit 0
    fi

    if [[ ! -f "$specific_file" ]]; then
        die "File not found: $specific_file"
    fi

    move_one_file "$specific_file"
}

# ------------------------------------------------------------
# Command: appimg update
# ------------------------------------------------------------
cmd_update() {
    local extract_icons=0
    local skip_extract=0
    local target_app_name=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --icon) extract_icons=1; shift ;;
            --icon-skip) skip_extract=1; shift ;;
            -*) die "Unknown option for update: $1" ;;
            *)
                if [[ -n "$target_app_name" ]]; then
                    die "update command only accepts one app name argument."
                fi
                target_app_name="$1"
                shift
                ;;
        esac
    done

    if [[ $extract_icons -eq 1 && $skip_extract -eq 1 ]]; then
        die "Cannot specify both --icon and --icon-skip."
    fi

    [[ ! -d "$APPIMG_DIR" ]] && die "$APPIMG_DIR does not exist."

    local dirs_to_update
    if [[ -n "$target_app_name" ]]; then
        local target_dir="$APPIMG_DIR/$target_app_name"
        if [[ ! -d "$target_dir" ]]; then
            die "Application '$target_app_name' not found."
        fi
        dirs_to_update=("$target_dir")
    else
        dirs_to_update=("$APPIMG_DIR"/*)
    fi

    for dir in "${dirs_to_update[@]}"; do
        [[ ! -d "$dir" ]] && continue
        local name
        name=$(basename "$dir")

        # The main appimage is the symlink if it exists
        local appimage="$dir/$name.AppImage"
        
        # Fallback to first found if no symlink (for unversioned apps)
        if [[ ! -e "$appimage" ]]; then
            appimage=$(find "$dir" -maxdepth 1 -type f -iname "*.AppImage" | head -n 1)
        fi
        
        [[ -z "$appimage" ]] && continue

        # The executable is the real file
        local executable_appimage
        executable_appimage=$(readlink -f "$appimage")
        
        chmod +x "$executable_appimage"
        
        local app_name_for_desktop
        app_name_for_desktop=$(basename "$dir")
        local desktop_file="$dir/$app_name_for_desktop.desktop"


        # Always attempt to extract icons since we need the embedded .desktop file info
        tmpdir=$(mktemp -d)
        (cd "$tmpdir" && "$executable_appimage" --appimage-extract >/dev/null 2>&1) || true

        local name_from_desktop_file=""
        local icon_name=""
        local desktop_name=""
        local terminal_from_desktop=""
        local categories_from_desktop=""

        if [[ -d "$tmpdir/squashfs-root" ]]; then
            # Try to pick the correct icon by reading the embedded .desktop file's Icon key
            desktop_inside=$(find "$tmpdir/squashfs-root" -type f -iname "*.desktop" | head -n 1)
            if [[ -n "$desktop_inside" ]]; then
                icon_name=$(grep -Ei '^Icon=' "$desktop_inside" | head -n1 | sed -E 's/Icon=//I') || true
                icon_name="${icon_name%%$'\r'}"

                desktop_name=$(grep -Ei '^Name=' "$desktop_inside" | head -n1 | sed -E 's/Name=//I') || true
                desktop_name="${desktop_name%%$'\r'}"
                if [[ -n "$desktop_name" ]]; then
                    name_from_desktop_file="$desktop_name"
                fi

                terminal_from_desktop=$(grep -Ei '^Terminal=' "$desktop_inside" | head -n1 | sed -E 's/Terminal=//I') || true
                terminal_from_desktop="${terminal_from_desktop%%$'\r'}"
                categories_from_desktop=$(grep -Ei '^Categories=' "$desktop_inside" | head -n1 | sed -E 's/Categories=//I') || true
                categories_from_desktop="${categories_from_desktop%%$'\r'}"
            fi

            icon=$(find "$dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
            if [[ -z "$icon" ]]; then
                if [[ $extract_icons -eq 1 ]]; then
                    extract_icon="y"
                elif [[ $skip_extract -eq 1 ]]; then
                    extract_icon="n"
                else
                    read -p "No icon found for $app_name_for_desktop. Would you like to try extracting icons from the AppImage? [y/N]: " extract_icon
                fi
                if [[ "$extract_icon" =~ ^[Yy]$ ]]; then

                    # Search for SVG first in common icon directories
                    icon_candidate=""
                    if [[ -n "$icon_name" ]]; then
                        icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.svg" -o -iname "${icon_name,,}.svg" -o -iname "${icon_name^^}.svg" \) | head -n 1 || true)
                    fi

                    # If no SVG or specific icon, try PNG in same dirs, pick largest
                    if [[ -z "$icon_candidate" ]]; then
                        mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.png" -o -iname "${icon_name,,}.png" -o -iname "${icon_name^^}.png" \))
                        best_png=""
                        best_size=0
                        for ic in "${png_candidates[@]}"; do
                            size=$(stat -c %s "$ic" 2>/dev/null)
                            if (( size > best_size )); then
                                best_size=$size
                                best_png="$ic"
                            fi
                        done
                        icon_candidate="$best_png"
                    fi

                    # If still not found, try XPM
                    if [[ -z "$icon_candidate" ]]; then
                        icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.xpm" -o -iname "${icon_name,,}.xpm" -o -iname "${icon_name^^}.xpm" \) | head -n 1 || true)
                    fi

                    # Fallback: pick the best SVG, else largest PNG, else largest XPM if no specific icon found
                    if [[ -z "$icon_candidate" ]]; then
                        # Prefer SVG
                        mapfile -t svg_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.svg' -not -iname '*thumbnail*')
                        if [[ ${#svg_candidates[@]} -gt 0 ]]; then
                            # Pick largest SVG
                            best_svg=""
                            best_size=0
                            for ic in "${svg_candidates[@]}"; do
                                size=$(stat -c %s "$ic" 2>/dev/null)
                                if (( size > best_size )); then
                                    best_size=$size
                                    best_svg="$ic"
                                fi
                            done
                            icon_candidate="$best_svg"
                        else
                            # Pick largest PNG
                            mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.png' -not -iname '*thumbnail*')
                            best_png=""
                            best_size=0
                            for ic in "${png_candidates[@]}"; do
                                size=$(stat -c %s "$ic" 2>/dev/null)
                                if (( size > best_size )); then
                                    best_size=$size
                                    best_png="$ic"
                                fi
                            done
                            icon_candidate="$best_png"
                            # If still not found, pick largest XPM
                            if [[ -z "$icon_candidate" ]]; then
                                mapfile -t xpm_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.xpm' -not -iname '*thumbnail*')
                                best_xpm=""
                                best_size=0
                                for ic in "${xpm_candidates[@]}"; do
                                    size=$(stat -c %s "$ic" 2>/dev/null)
                                    if (( size > best_size )); then
                                        best_size=$size
                                        best_xpm="$ic"
                                    fi
                                done
                                icon_candidate="$best_xpm"
                            fi
                        fi
                    fi

                    if [[ -n "$icon_candidate" ]]; then
                        ext="${icon_candidate##*.}"
                        cp "$icon_candidate" "$dir/icon.$ext" 2>/dev/null || true
                        icon="$dir/icon.$ext"
                        # Create .noiconkeep marker file
                        touch "$dir/.noiconkeep"
                    else
                        icon="$APPIMG_DIR/placeholder-icon.png"
                    fi
                else # User chose not to extract icons
                    icon="$APPIMG_DIR/placeholder-icon.png"
                fi
            fi
        else # squashfs-root not found, extraction failed or not an AppImage
            icon="$APPIMG_DIR/placeholder-icon.png"
        fi
        rm -rf "$tmpdir"

        # Use name from .desktop file if available, otherwise fallback to directory name
        local app_name_for_desktop_entry="${name_from_desktop_file:-$app_name_for_desktop}"
        local terminal_for_desktop_entry="${terminal_from_desktop:-false}"
        local categories_for_desktop_entry="${categories_from_desktop:-Utility;}"

        echo "Generating $desktop_file"

        cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=$app_name_for_desktop_entry
Exec="$appimage"
Icon=$icon
Terminal=$terminal_for_desktop_entry
Categories=$categories_for_desktop_entry
EOF

        chmod +x "$desktop_file"

        # Symlink into applications directory
        ln -sf "$desktop_file" "$DESKTOP_TARGET/$app_name_for_desktop.desktop"
        echo "Linked → $DESKTOP_TARGET/$app_name_for_desktop.desktop"
    done
}


# ------------------------------------------------------------
# Command: appimg setup-all
# ------------------------------------------------------------
cmd_setup_all() {
    local extract_icons=0
    local skip_extract=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --icon) extract_icons=1; shift ;;
            --icon-skip) skip_extract=1; shift ;;
            *) shift ;;
        esac
    done

    if [[ $extract_icons -eq 1 && $skip_extract -eq 1 ]]; then
        die "Cannot specify both --icon and --icon-skip."
    fi

    cmd_move --all
    if [[ $extract_icons -eq 1 ]]; then
        cmd_update --icon
    elif [[ $skip_extract -eq 1 ]]; then
        cmd_update --icon-skip
    else
        cmd_update
    fi
}


# ------------------------------------------------------------
# Command: appimg reset
# ------------------------------------------------------------
cmd_reset() {
    echo "Resetting AppImage structure..."

    # ---------------------------------------------
    # 1. Remove all .desktop symlinks pointing to ~/.appimages
    # ---------------------------------------------
    echo "Removing AppImage desktop entry symlinks..."
    find "$DESKTOP_TARGET" -type l | while IFS= read -r link; do
        target="$(readlink -f "$link")"
        if [[ "$target" == "$APPIMG_DIR"* ]]; then
            echo "Deleting symlink: $link"
            rm -f "$link"
        fi
    done

    mkdir -p "$APPIMG_DIR/tmp"

    # ---------------------------------------------
    # 2. Move all AppImage files and their icons into tmp/
    # ---------------------------------------------
    find "$APPIMG_DIR" -mindepth 2 -type f -iname "*.AppImage" | while IFS= read -r f; do
        file_name=$(basename "$f")
        app_dir=$(dirname "$f")
        echo "Moving $f → $APPIMG_DIR/tmp/$file_name"
        mv "$f" "$APPIMG_DIR/tmp/$file_name" || continue

        # Check for .noiconkeep marker; if present, skip moving icon
        if [[ ! -f "$app_dir/.noiconkeep" ]]; then
            icon=$(find "$app_dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
            if [[ -n "$icon" && -f "$icon" ]]; then
                icon_ext="${icon##*.}"
                base_name="${file_name%.[Aa][Pp][Pp][Ii][Mm][Aa][Gg][Ee]}"
                app_name="${base_name%%#*}"
                icon_name="${app_name}-icon.$icon_ext"
                echo "Moving icon $icon → $APPIMG_DIR/tmp/$icon_name"
                mv "$icon" "$APPIMG_DIR/tmp/$icon_name" || echo "Failed to move icon $icon"
            fi
        else
            echo "Skipping icon move for $app_dir due to .noiconkeep"
        fi
    done

    # ---------------------------------------------
    # 3. Delete all folders inside ~/.appimages
    #    except: tmp/ and placeholder-icon.png
    # ---------------------------------------------
    for item in "$APPIMG_DIR"/*; do
        base="$(basename "$item")"
        [[ "$base" == "tmp" ]] && continue
        [[ "$base" == "placeholder-icon.png" ]] && continue
        if [[ -d "$item" ]]; then
            echo "Deleting folder: $item"
            rm -rf "$item"
        fi
    done

    # ---------------------------------------------
    # 4. Remove executable bit from all AppImages in tmp
    # ---------------------------------------------
    echo "Removing executable permissions from AppImages in tmp/"
    shopt -s nullglob
    for f in "$APPIMG_DIR"/tmp/*.AppImage; do
        chmod -x "$f"
    done
    shopt -u nullglob

    echo "Reset complete! Run 'appimg setup-all' to rebuild."
}


# ------------------------------------------------------------
# Command: appimg select
# ------------------------------------------------------------
cmd_select() {
    [[ $# -eq 0 ]] && die "Usage: appimg select <appname> [--switch <version>]"
    local app_name="$1"
    shift
    local app_dir="$APPIMG_DIR/$app_name"
    [[ ! -d "$app_dir" ]] && die "Application not found: $app_name"

    local do_switch=0
    local target_version=""
    if [[ "$1" == "--switch" ]]; then
        do_switch=1
        target_version="$2"
        [[ -z "$target_version" ]] && die "No version specified for --switch"
        shift 2
    fi

    # --- List versions ---
    if [[ $do_switch -eq 0 ]]; then
        echo "Available versions for $app_name:"
        local active_path=""
        local symlink_target=""
        if [[ -L "$app_dir/$app_name.AppImage" ]]; then
            active_path=$(readlink "$app_dir/$app_name.AppImage")
            symlink_target=$(basename "$active_path")
        fi

        shopt -s nullglob
        local versions=("$app_dir/$app_name"#*.AppImage)
        shopt -u nullglob

        if [[ ${#versions[@]} -eq 0 ]]; then
            if [[ -f "$app_dir/$app_name.AppImage" ]]; then
                echo " * $(basename "$app_dir/$app_name.AppImage") (active, no versions)"
            else
                echo "No versions found."
            fi
            return
        fi

        for v_path in "${versions[@]}"; do
            v_base=$(basename "$v_path")
            if [[ "$v_base" == "$symlink_target" ]]; then
                echo " * $v_base (active)"
            else
                echo "   $v_base"
            fi
        done
        return
    fi

    # --- Switch version ---
    if [[ $do_switch -eq 1 ]]; then
        local target_appimage_path=""
        # Try to match version string directly
        shopt -s nullglob
        local found_versions=("$app_dir/$app_name#$target_version.AppImage" "$app_dir/$app_name#$target_version" "$app_dir/$target_version")
        for v in "${found_versions[@]}"; do
             if [[ -f "$v" ]]; then
                target_appimage_path="$v"
                break
             fi
        done

        if [[ -z "$target_appimage_path" && -f "$app_dir/$target_version" ]]; then
            target_appimage_path="$app_dir/$target_version"
        fi
        
        # Try to match by index if not found (and is a number)
        if [[ -z "$target_appimage_path" && "$target_version" =~ ^[0-9]+$ ]]; then
            mapfile -t versions_sorted < <(find "$app_dir" -maxdepth 1 -type f -name "$app_name#*.AppImage" | sort -V)
            if [[ ${#versions_sorted[@]} -gt 0 && $target_version -gt 0 && $target_version -le ${#versions_sorted[@]} ]]; then
                target_appimage_path="${versions_sorted[$target_version-1]}"
            fi
        fi

        if [[ -z "$target_appimage_path" || ! -f "$target_appimage_path" ]]; then
            die "Version '$target_version' not found for $app_name."
        fi

        local symlink="$app_dir/$app_name.AppImage"
        local target_basename
        target_basename=$(basename "$target_appimage_path")
        (cd "$app_dir" && ln -sf "$target_basename" "$app_name.AppImage")
        echo "Switched $app_name to $target_basename"
        cmd_update "$app_name"
    fi
}


# ------------------------------------------------------------
# Command: appimg help
# ------------------------------------------------------------
cmd_help() {
    echo "AppImage manager"
    echo "Commands:"
    echo "  appimg ls [-s dir]"
    echo "  appimg move [--all] [-s dir] [file.AppImage]"
    echo "  appimg update [APPNAME] [--icon|--icon-skip]"
    echo "  appimg setup-all [--icon|--icon-skip]"
    echo "  appimg reset"
    echo "  appimg select <appname> [--switch <version>]"
    echo "  appimg version"
    echo "  appimg -v"
    echo "  appimg help"
}


# ------------------------------------------------------------
# Command: appimg version
# ------------------------------------------------------------
cmd_version() {
    echo "appimg version $VERSION"
}


# ------------------------------------------------------------
# Dispatcher
# ------------------------------------------------------------
main() {
    case "$1" in
        ls)        shift; cmd_ls "$@" ;;
        move)      shift; cmd_move "$@" ;;
        update)    shift; cmd_update "$@" ;;
        setup-all) shift; cmd_setup_all "$@" ;;
        reset)     shift; cmd_reset ;;
        select)    shift; cmd_select "$@" ;;
        version|-v) shift; cmd_version "$@" ;;
        help)      shift; cmd_help ;;
        version)   shift; cmd_version ;;
        *)
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
