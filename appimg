#!/usr/bin/env bash

# ============================================================
# appimg - AppImage manager tool
# Commands:
#   appimg ls
#   appimg run
#   appimg move [--all] [-s dir] [file.AppImage]
#   appimg update
#   appimg setup-all
#   appimg reset
#   appimg open
#   appimg version
#   appimg help
# ============================================================

VERSION="0.4.1"
APPIMG_DIR="$HOME/.appimages"
DESKTOP_TARGET="${XDG_DATA_HOME:-$HOME/.local/share}/applications"

# Ensure ~/.local/share/applications exists
mkdir -p "$DESKTOP_TARGET"


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
die() {
    local msg="$*"

    # Terminal: print to stderr
    if [[ -t 2 ]]; then
        printf 'Error: %s\n' "$msg" >&2

    # GUI session: show dialog / notification
    elif [[ -n "$DISPLAY$WAYLAND_DISPLAY" ]]; then
        if command -v zenity >/dev/null 2>&1; then
            zenity --error --title="appimg" --text="$msg"
        elif command -v notify-send >/dev/null 2>&1; then
            notify-send "appimg error" "$msg"
        fi
    fi

    exit 1
}


init_dmenu() {
    local MANAGED_DIR="${APPIMG_DIR:-$HOME/.appimages}/managed"
    local BIN_DIR="$HOME/.local/bin"

    # 1. HANDLE RESET OPTION (Cleaning "Ghost" Links)
    if [[ "$1" == "-r" || "$1" == "--reset" ]]; then
        echo "Cleaning up symlinks in $BIN_DIR..."
        
        if [ -d "$BIN_DIR" ]; then
            # Phase A: Remove BROKEN links (files that no longer exist)
            # -xtype l finds symbolic links that are "dangling"
            find "$BIN_DIR" -maxdepth 1 -xtype l -delete
            echo "✓ cleaned all."

            # Phase B: Remove links that DO exist but point to our managed folder
            local ABS_MANAGED_DIR=$(readlink -f "$MANAGED_DIR" | sed 's:/*$::')
            for link in "$BIN_DIR"/*; do
                if [ -L "$link" ]; then
                    local TARGET=$(readlink -f "$link")
                    if [[ "$TARGET" == "$ABS_MANAGED_DIR"/* ]]; then
                        echo "✓ Removing managed link: $(basename "$link")"
                        rm "$link"
                    fi
                fi
            done
        fi
        return 0
    fi

    # 2. STANDARD PRE-FLIGHT
    if ! command -v dmenu >/dev/null 2>&1; then return 1; fi
    mkdir -p "$BIN_DIR"

    # 3. SYNC LOGIC
    echo "Linking binaries to $BIN_DIR..."
    find "$MANAGED_DIR" -maxdepth 2 -name "*.AppImage" | while read -r app; do
        app_name=$(basename "$app" .AppImage | tr '[:upper:]' '[:lower:]')
        ln -sf "$app" "$BIN_DIR/$app_name"
    done

    # 4. PATH CHECK
    if [[ ":$PATH:" != *":$BIN_DIR:"* ]]; then
        echo "--------------------------------------------------------"
        echo "NOTICE: $BIN_DIR is NOT in your \$PATH."
        echo "--------------------------------------------------------"
    fi
}

find_appimages() {
    local search_dir="$1"
    find "$search_dir" -type f -iname "*.AppImage" -not -path "$APPIMG_DIR/managed/*" 2>/dev/null
}

find_all_appimages() {
    local search_dir="$1"
    find "$search_dir" -type f -iname "*.AppImage" 2>/dev/null
}

appname_from_path() {
    basename "$1" | sed -E 's/(\.AppImage$|#active)//i'
}

# New helper function
get_appimage_metadata() {
    local f="$1"
    local desktop_id=""
    local has_active=0

    if echo "$(basename "$f")" | grep -q '#active'; then
        has_active=1
    fi

    local tmpdir
    tmpdir=$(mktemp -d)

    chmod +x "$f"
    (cd "$tmpdir" && "$f" --appimage-extract '*.desktop') >/dev/null 2>&1 || true

    if [[ ! -d "$tmpdir/squashfs-root" ]]; then
        (cd "$tmpdir" && "$f" --appimage-extract) >/dev/null 2>&1 || true
    fi

    if [[ -d "$tmpdir/squashfs-root" ]]; then
        local all_desktop_files
        all_desktop_files=$(ls -1 "$tmpdir/squashfs-root" | grep ".desktop$")
            
        local desktop_file
        desktop_file=$(echo "$all_desktop_files" | grep -v "url-handler.desktop" | head -n 1)

        if [[ -z "$desktop_file" ]]; then
            desktop_file=$(echo "$all_desktop_files" | head -n 1)
        fi

        if [[ -n "$desktop_file" ]]; then
            desktop_id=$(basename "$desktop_file" .desktop)
        fi
    fi
    rm -rf "$tmpdir"

    echo "$desktop_id|$has_active"
}


# ------------------------------------------------------------
# Command: appimg ls
# ------------------------------------------------------------
cmd_ls() {
    local search="$HOME"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            *) die "Unknown option for ls: $1" ;;
        esac
    done

    mapfile -t files < <(find_all_appimages "$search")

    for f in "${files[@]}"; do
        if [[ "$(readlink -f "$f")" == "$APPIMG_DIR/managed/"* ]]; then
            echo "$f (managed)"
        else
            echo "$f"
        fi
    done
}

# ------------------------------------------------------------
# Command: appimg run
# ------------------------------------------------------------
cmd_run() {
    local appimage_path="$1"

    [[ -z "$appimage_path" ]] && die "No AppImage path provided."
    [[ ! -f "$appimage_path" ]] && die "AppImage not found: $appimage_path"

    # Ensure executable (ignore failure on read-only FS)
    [[ -x "$appimage_path" ]] || chmod +x "$appimage_path" 2>/dev/null || true

    # NixOS detection (non-FHS)
    if [[ -f /etc/NIXOS ]]; then
        if command -v appimage-run >/dev/null 2>&1; then
            exec appimage-run "$appimage_path" "${@:2}"
        else
            die "NixOS detected (non-FHS). Install: appimage-run"
        fi
    else
        exec "$appimage_path" "${@:2}"
    fi
}

# ------------------------------------------------------------
# Command: appimg move
# ------------------------------------------------------------
cmd_move() {
    local search="$HOME"
    local do_all=0
    local specific_file=""
    local target_dir=""
    local args=()
    
    # Capture all arguments after options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            --all) do_all=1; shift ;;
            *) args+=("$1"); shift ;;
        esac
    done

    # Determine file and target_dir from remaining arguments
    if [[ "${#args[@]}" -eq 1 ]]; then
        if [[ "$do_all" -eq 1 ]]; then
            target_dir="${args[0]}"
        else
            specific_file="${args[0]}"
        fi
    elif [[ "${#args[@]}" -eq 2 ]]; then
        if [[ "$do_all" -eq 1 ]]; then
            die "move --all takes at most one directory argument."
        fi
        specific_file="${args[0]}"
        target_dir="${args[1]}"
    elif [[ "${#args[@]}" -gt 2 ]]; then
        die "Too many arguments for move."
    fi

    # Path 1: A target directory is specified. Move files and exit.
    if [[ -n "$target_dir" ]]; then
        if [[ ! -d "$target_dir" ]]; then
            echo "Creating directory: $target_dir"
            mkdir -p "$target_dir" || die "Could not create directory $target_dir"
        fi

        if [[ "$do_all" -eq 1 ]]; then
            mapfile -t files_to_move < <(find_appimages "$search")
            if [[ ${#files_to_move[@]} -eq 0 ]]; then
                echo "No unmanaged AppImages found in '$search' to move."
                return
            fi
            for f in "${files_to_move[@]}"; do
                echo "Moving $f → $target_dir/"
                mv "$f" "$target_dir/" || die "Failed to move $f"
            done
        else # specific file
            if [[ -z "$specific_file" ]]; then
                die "You must provide a file to move."
            fi
            if [[ ! -f "$specific_file" ]]; then
                die "File not found: $specific_file"
            fi
            # Check if it's in the managed directory
            local full_path
            full_path=$(readlink -f "$specific_file")
            if [[ "$full_path" == "$APPIMG_DIR/managed/"* ]]; then
                 echo "Skipping move: $specific_file is already managed."
                 return
            fi
            echo "Moving $specific_file → $target_dir/"
            mv "$specific_file" "$target_dir/" || die "Failed to move $specific_file"
        fi
        return # We are done.
    fi

    # Path 2: No target directory. Use the management logic.
    if [[ "$do_all" -eq 0 && -z "$specific_file" ]]; then
        die "You must provide a file or use --all"
    fi

    mkdir -p "$APPIMG_DIR/managed"
    mkdir -p "$APPIMG_DIR/unmanaged"

    declare -a all_appimages_info # To store path|desktop_id|has_active for all found AppImages

    if [[ "$do_all" -eq 1 ]]; then
        mapfile -t files < <(find_appimages "$search")
        if [[ ${#files[@]} -eq 0 ]]; then
            echo "No AppImages found in '$search'."
            return
        fi
        for f in "${files[@]}"; do
            # The check for managed files is now in find_appimages
            read -r desktop_id has_active <<< "$(get_appimage_metadata "$f")"
            all_appimages_info+=("$f|$desktop_id|$has_active")
        done
    elif [[ -n "$specific_file" ]]; then
        if [[ ! -f "$specific_file" ]]; then
            die "File not found: $specific_file"
        fi
        # Check if it's in the managed directory
        local full_path
        full_path=$(readlink -f "$specific_file")
        if [[ "$full_path" == "$APPIMG_DIR/managed/"* ]]; then
                echo "Skipping move: $specific_file is already managed."
                return
        fi
        read -r desktop_id has_active <<< "$(get_appimage_metadata "$specific_file")"
        all_appimages_info+=("$specific_file|$desktop_id|$has_active")
    fi

    # Group AppImages by desktop ID (or 'no_desktop_id' if none found)
    declare -A grouped_appimages # key: desktop_id, value: newline-separated list of "path|has_active"

    for info_string in "${all_appimages_info[@]}"; do
        IFS='|' read -r path desktop_id has_active <<< "$info_string"
        if [[ -z "$desktop_id" ]]; then
            if [[ "$has_active" -eq 1 ]]; then
                desktop_id=$(appname_from_path "$path")
            else
                desktop_id="no_desktop_id"
            fi
        fi

        if [[ -n "${grouped_appimages[$desktop_id]}" ]]; then
            grouped_appimages[$desktop_id]+=$'\n'
        fi
        grouped_appimages[$desktop_id]+="$path|$has_active"
    done

    # Process grouped AppImages by desktop ID
    for desktop_id in "${!grouped_appimages[@]}"; do
        # Convert newline-separated string to array, preserving spaces in filenames
        mapfile -t app_files_info < <(echo "${grouped_appimages[$desktop_id]}")
        
        local primary_app_path=""
        local active_app_path=""
        local first_valid_app_path=""

        # Find the primary AppImage: prioritize #active, otherwise take the first valid one
        for app_info in "${app_files_info[@]}"; do
            if [[ -z "$app_info" ]]; then continue; fi
            IFS='|' read -r current_path current_has_active <<< "$app_info"
            if [[ "$current_has_active" -eq 1 ]]; then
                active_app_path="$current_path"
            fi
            if [[ -z "$first_valid_app_path" ]]; then
                first_valid_app_path="$current_path"
            fi
        done
        
        if [[ -n "$active_app_path" ]]; then
            primary_app_path="$active_app_path"
        else
            primary_app_path="$first_valid_app_path"
        fi
        

        # If still no primary app (e.g., no files or all were managed), skip
        if [[ -z "$primary_app_path" ]]; then
            continue
        fi

        local dest_dir="$APPIMG_DIR/managed/$desktop_id"
        local dest_appimage="$dest_dir/$(basename "$primary_app_path")"
        local existing_managed_appimage=""

        # Check if an appimage for this desktop_id already exists in managed/
        if [[ -d "$dest_dir" ]]; then
            existing_managed_appimage=$(find "$dest_dir" -maxdepth 1 -type f -iname "*.AppImage" | head -n 1)
        fi

        # Move the primary AppImage
        mkdir -p "$dest_dir"
        if [[ -n "$existing_managed_appimage" && "$(readlink -f "$primary_app_path")" != "$(readlink -f "$existing_managed_appimage")" ]]; then
            echo "Overwriting existing managed AppImage for $desktop_id with $primary_app_path"
            mv -f "$primary_app_path" "$dest_appimage" || die "Failed to move $primary_app_path"
        elif [[ -z "$existing_managed_appimage" ]]; then
            echo "Moving $primary_app_path → $dest_appimage"
            mv "$primary_app_path" "$dest_appimage" || die "Failed to move $primary_app_path"
        elif [[ "$(readlink -f "$primary_app_path")" == "$(readlink -f "$existing_managed_appimage")" ]]; then
            echo "Skipping move: $primary_app_path is already the managed version."
        fi

        # Move any other AppImages in this group (that are not the primary) to unmanaged
        for app_info in "${app_files_info[@]}"; do
            if [[ -z "$app_info" ]]; then continue; fi
            IFS='|' read -r current_path current_has_active <<< "$app_info"
            if [[ "$current_path" != "$primary_app_path" ]]; then
                local unmanaged_name
                unmanaged_name=$(basename "$current_path")
                local unmanaged_dir="$APPIMG_DIR/unmanaged"

                # Don't move if it's already in the target directory
                if [[ "$(readlink -f "$current_path")" != "$(readlink -f "$unmanaged_dir/$unmanaged_name")" ]]; then
                    echo "Moving $current_path → $unmanaged_dir/$unmanaged_name (duplicate/non-primary for $desktop_id)"
                    mv "$current_path" "$unmanaged_dir/$unmanaged_name" || die "Failed to move $current_path to unmanaged."
                fi
            fi
        done
    done

    # Move any AppImages that ended up in the 'no_desktop_id' group and were not chosen as primary (which shouldn't happen if #active logic is working)
    # This loop specifically handles files that never had a desktop_id and were not selected as active.
    if [[ -n "${grouped_appimages['no_desktop_id']}" ]]; then
        IFS=$'\n' read -ra no_id_files_info <<< "${grouped_appimages['no_desktop_id']}"
        for app_info in "${no_id_files_info[@]}"; do
            if [[ -z "$app_info" ]]; then continue; fi
            IFS='|' read -r current_path current_has_active <<< "$app_info"
            
            # Check if this file was already moved as a primary (which should not happen for 'no_desktop_id' if logic is robust)
            # Or if it was already moved as a duplicate.
            # This is a final catch-all.
            if [[ ! -f "$current_path" ]]; then # If file doesn't exist, it has already been moved
                continue
            fi
            
            local unmanaged_name=$(basename "$current_path")
            echo "Moving $current_path → $APPIMG_DIR/unmanaged/$unmanaged_name \(no desktop ID\)"
            mv "$current_path" "$APPIMG_DIR/unmanaged/$unmanaged_name" || die "Failed to move $current_path to unmanaged."
        done
    fi
}

# ------------------------------------------------------------
# Command: appimg update
# ------------------------------------------------------------
cmd_update() {
    local target_app_name=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) die "Unknown option for update: $1" ;;
            *)
                if [[ -n "$target_app_name" ]]; then
                    die "update command only accepts one app name argument."
                fi
                target_app_name="$1"
                shift
                ;;
        esac
    done

    [[ ! -d "$APPIMG_DIR" ]] && die "$APPIMG_DIR does not exist."

    local dirs_to_update
    if [[ -n "$target_app_name" ]]; then
        local target_dir="$APPIMG_DIR/managed/$target_app_name"
        if [[ ! -d "$target_dir" ]]; then
            die "Application '$target_app_name' not found."
        fi
        dirs_to_update=("$target_dir")
    else
        dirs_to_update=("$APPIMG_DIR/managed"/*)
    fi

    for dir in "${dirs_to_update[@]}"; do
        [[ ! -d "$dir" ]] && continue
        local name
        name=$(basename "$dir")

        # The main appimage is the symlink if it exists
        local appimage="$dir/$name.AppImage"
        
        # Fallback to first found if no symlink (for unversioned apps)
        if [[ ! -e "$appimage" ]]; then
            appimage=$(find "$dir" -maxdepth 1 -type f -iname "*.AppImage" | head -n 1)
        fi
        
        [[ -z "$appimage" ]] && continue

        # The executable is the real file
        local executable_appimage
        executable_appimage=$(readlink -f "$appimage")
        
        chmod +x "$executable_appimage"
        
        local app_name_for_desktop
        app_name_for_desktop=$(basename "$dir")
        local desktop_file="$dir/$app_name_for_desktop.desktop"


        local name_from_desktop_file=""
        local icon=""
        local terminal_from_desktop=""
        local categories_from_desktop=""

        # Always attempt to extract icons since we need the embedded .desktop file info
        tmpdir=$(mktemp -d)
        
        # Define glob patterns for targeted extraction
        local glob_patterns=(
            '*.desktop'
            'usr/share/applications/*.desktop'
            'share/applications/*.desktop'
            'usr/share/icons/**/*'
            'share/icons/**/*'
            'usr/share/pixmaps/*'
            'share/pixmaps/*'
            '*.png'
            '*.svg'
            '**/*.ico'
        )

        # Perform targeted extraction for each glob pattern
        local extracted_successfully=false
        for pattern in "${glob_patterns[@]}"; do
            (cd "$tmpdir" && "$executable_appimage" --appimage-extract "$pattern") >/dev/null 2>&1 || true
            if [[ -d "$tmpdir/squashfs-root" ]]; then
                extracted_successfully=true
            fi
        done
        
        # If the above fails to create squashfs-root or get files, perform a full extract as fallback
        if [[ "$extracted_successfully" == "false" ]]; then
            echo "Warning: Targeted extraction failed, falling back to full extraction for $executable_appimage." >&2
            (cd "$tmpdir" && "$executable_appimage" --appimage-extract >/dev/null 2>&1) || true
        fi

        if [[ ! -d "$tmpdir/squashfs-root" ]]; then
            echo "Warning: Failed to extract squashfs-root for $executable_appimage. Skipping." >&2
            rm -rf "$tmpdir"
            continue # Move to next AppImage in the loop
        fi

        local icon_name=""
        local desktop_name=""

        if [[ -d "$tmpdir/squashfs-root" ]]; then
            # Try to pick the correct icon by reading the embedded .desktop file's Icon key
            desktop_inside=$(find "$tmpdir/squashfs-root" -type f -iname "*.desktop" | head -n 1)
            if [[ -n "$desktop_inside" ]]; then
                icon_name=$(grep -Ei '^Icon=' "$desktop_inside" | head -n1 | sed -E 's/Icon=//I') || true
                icon_name="${icon_name%%$'\r'}"

                desktop_name=$(grep -Ei '^Name=' "$desktop_inside" | head -n1 | sed -E 's/Name=//I') || true
                desktop_name="${desktop_name%%$'\r'}"
                if [[ -n "$desktop_name" ]]; then
                    name_from_desktop_file="$desktop_name"
                fi

                terminal_from_desktop=$(grep -Ei '^Terminal=' "$desktop_inside" | head -n1 | sed -E 's/Terminal=//I') || true
                terminal_from_desktop="${terminal_from_desktop%%$'\r'}"
                categories_from_desktop=$(grep -Ei '^Categories=' "$desktop_inside" | head -n1 | sed -E 's/Categories=//I') || true
                categories_from_desktop="${categories_from_desktop%%$'\r'}"
            fi

            icon=$(find "$dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
            if [[ -z "$icon" ]]; then

                # Search for SVG first in common icon directories
                icon_candidate=""
                if [[ -n "$icon_name" ]]; then
                    icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.svg" -o -iname "${icon_name,,}.svg" -o -iname "${icon_name^^}.svg" \) | head -n 1 || true)
                fi

                # If no SVG or specific icon, try PNG in same dirs, pick largest
                if [[ -z "$icon_candidate" ]]; then
                    mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.png" -o -iname "${icon_name,,}.png" -o -iname "${icon_name^^}.png" \))
                    best_png=""
                    best_size=0
                    for ic in "${png_candidates[@]}"; do
                        size=$(stat -c %s "$ic" 2>/dev/null)
                        if (( size > best_size )); then
                            best_size=$size
                            best_png="$ic"
                        fi
                    done
                    icon_candidate="$best_png"
                fi

                # If still not found, try XPM
                if [[ -z "$icon_candidate" ]]; then
                    icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.xpm" -o -iname "${icon_name,,}.xpm" -o -iname "${icon_name^^}.xpm" \) | head -n 1 || true)
                fi

                # Fallback: pick the best SVG, else largest PNG, else largest XPM if no specific icon found
                if [[ -z "$icon_candidate" ]]; then
                    # Prefer SVG
                    mapfile -t svg_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.svg' -not -iname '*thumbnail*')
                    if [[ ${#svg_candidates[@]} -gt 0 ]]; then
                        # Pick largest SVG
                        best_svg=""
                        best_size=0
                        for ic in "${svg_candidates[@]}"; do
                            size=$(stat -c %s "$ic" 2>/dev/null)
                            if (( size > best_size )); then
                                best_size=$size
                                best_svg="$ic"
                            fi
                        done
                        icon_candidate="$best_svg"
                    else
                        # Pick largest PNG
                        mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.png' -not -iname '*thumbnail*')
                        best_png=""
                        best_size=0
                        for ic in "${png_candidates[@]}"; do
                            size=$(stat -c %s "$ic" 2>/dev/null)
                            if (( size > best_size )); then
                                best_size=$size
                                best_png="$ic"
                            fi
                        done
                        icon_candidate="$best_png"
                        # If still not found, pick largest XPM
                        if [[ -z "$icon_candidate" ]]; then
                            mapfile -t xpm_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.xpm' -not -iname '*thumbnail*')
                            best_xpm=""
                            best_size=0
                            for ic in "${xpm_candidates[@]}"; do
                                size=$(stat -c %s "$ic" 2>/dev/null)
                                if (( size > best_size )); then
                                    best_size=$size
                                    best_xpm="$ic"
                                fi
                            done
                            icon_candidate="$best_xpm"
                        fi
                    fi
                fi

                if [[ -n "$icon_candidate" ]]; then
                    ext="${icon_candidate##*.}"
                    cp "$icon_candidate" "$dir/icon.$ext" 2>/dev/null || true
                    icon="$dir/icon.$ext"
                    # Create .noiconkeep marker file
                    touch "$dir/.noiconkeep"
                fi
            fi
            rm -rf "$tmpdir"
        fi

        if [[ -z "$icon" ]]; then
            icon=$(find "$dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
        fi
        if [[ -z "$icon" ]]; then
            icon="$APPIMG_DIR/placeholder-icon.png"
        fi

        # Use name from .desktop file if available, otherwise fallback to directory name
        local app_name_for_desktop_entry="${name_from_desktop_file:-$app_name_for_desktop}"
        local terminal_for_desktop_entry="${terminal_from_desktop:-false}"
        local categories_for_desktop_entry="${categories_from_desktop:-Utility;}"

        echo "Generating $desktop_file"

        cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=$app_name_for_desktop_entry
Exec="$(readlink -f "$0")" run "$appimage"
Icon=$icon
Terminal=$terminal_for_desktop_entry
Categories=$categories_for_desktop_entry
EOF

        chmod +x "$desktop_file"

        # Symlink into applications directory
        ln -sf "$desktop_file" "$DESKTOP_TARGET/$app_name_for_desktop.desktop"
        echo "Linked → $DESKTOP_TARGET/$app_name_for_desktop.desktop"

        init_dmenu
    done
}


# ------------------------------------------------------------
# Command: appimg setup-all
# ------------------------------------------------------------
cmd_setup_all() {
    cmd_move --all
    cmd_update
}


# ------------------------------------------------------------
# Command: appimg reset
# ------------------------------------------------------------
cmd_reset() {
    echo "Resetting AppImage structure..."

    # ---------------------------------------------
    # 1. Remove all .desktop symlinks pointing to ~/.appimages
    # ---------------------------------------------
    echo "Removing AppImage desktop entry symlinks..."
    find "$DESKTOP_TARGET" -type l | while IFS= read -r link; do
        target="$(readlink -f "$link")"
        if [[ "$target" == "$APPIMG_DIR"* ]]; then
            echo "Deleting symlink: $link"
            rm -f "$link"
        fi
    done

    # ---------------------------------------------
    # 2. Move all AppImage files from managed/ to unmanaged/
    # ---------------------------------------------
    echo "Moving managed AppImages to unmanaged..."
    find "$APPIMG_DIR/managed" -type f -iname "*.AppImage" | while IFS= read -r f; do
        file_name=$(basename "$f")
        echo "Moving $f → $APPIMG_DIR/unmanaged/$file_name"
        mv "$f" "$APPIMG_DIR/unmanaged/$file_name" || continue
    done

    # ---------------------------------------------
    # 3. Delete all managed folders
    # ---------------------------------------------
    echo "Deleting managed AppImage directories..."
    find "$APPIMG_DIR/managed" -mindepth 1 -type d -exec rm -rf {} + 2>/dev/null || true

    init_dmenu --reset
}

# ------------------------------------------------------------
# Command: appimg open
# ------------------------------------------------------------
cmd_open() {
    # Get list of subdirectories containing .desktop files
    options=()
    while IFS= read -r -d $'\0' dir; do
        options+=("$(basename "$dir")")
    done < <(find "$APPIMG_DIR/managed" -mindepth 1 -maxdepth 1 -type d -exec sh -c 'ls "$1"/*.desktop 2>/dev/null | grep -q .' _ {} \; -print0)

    # Exit if no apps found
    [[ ${#options[@]} -eq 0 ]] && { echo "No AppImages with .desktop files found in $APPIMG_DIR/managed"; exit 1; }

    index=0

    draw_menu() {
        clear
        echo "Select AppImage to open:"
        for i in "${!options[@]}"; do
            if [ "$i" -eq "$index" ]; then
                echo -e "> \033[1;32m${options[$i]}\033[0m"
            else
                echo "  ${options[$i]}"
            fi
        done
    }

    while true; do
        draw_menu
        read -rsn1 key
        if [[ $key == $'\x1b' ]]; then
            read -rsn2 -t 0.1 key
            if [[ $key == "[A" ]]; then
                ((index--))
                ((index<0)) && index=$((${#options[@]}-1))
            elif [[ $key == "[B" ]]; then
                ((index++))
                ((index>=${#options[@]})) && index=0
            fi
        elif [[ $key == "" ]]; then
            selected_dir="$APPIMG_DIR/managed/${options[$index]}"
            desktop_file=$(find "$selected_dir" -maxdepth 1 -name '*.desktop' | head -n1)

            if [[ -f "$desktop_file" ]]; then
                echo "Launching $(basename "$desktop_file")..."
                # Extract and run the command in Exec= (handles spaces)
                # Get the command line from the .desktop file
                cmd=$(grep -E '^Exec=' "$desktop_file" | head -n1 | cut -d'=' -f2-)

                # Remove any placeholders like %U, %f, etc.
                cmd=${cmd//%[fFuUdDnN]/}

                # Run it safely
                bash -c "$cmd"                
            else
                echo "No .desktop file found in $selected_dir!"
            fi
            break
        fi
    done
}

# ------------------------------------------------------------
# Command: appimg help
# ------------------------------------------------------------
cmd_help() {
    echo "AppImage manager"
    echo "Commands:"
    echo "  appimg ls [-s dir]"
    echo "  appimg move [--all] [-s dir] [file.AppImage]"
    echo "  appimg update [APPNAME]"
    echo "  appimg setup-all"
    echo "  appimg reset"
    echo "  appimg open"
    echo "  appimg version"
    echo "  appimg -v"
    echo "  appimg help"
}


# ------------------------------------------------------------
# Command: appimg version
# ------------------------------------------------------------
cmd_version() {
    echo "appimg version $VERSION"
}


# ------------------------------------------------------------
# Dispatcher
# ------------------------------------------------------------
main() {
    case "$1" in
        ls)        shift; cmd_ls "$@" ;;
        run)       shift; cmd_run "$@" ;;
        move)      shift; cmd_move "$@" ;;
        update)    shift; cmd_update "$@" ;;
        setup-all) shift; cmd_setup_all "$@" ;;
        reset)     shift; cmd_reset ;;
        open)     shift; cmd_open ;;
        version|-v) shift; cmd_version "$@" ;;
        help)      shift; cmd_help ;;
        version)   shift; cmd_version ;;
        *)
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
