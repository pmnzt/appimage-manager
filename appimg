#!/usr/bin/env bash

# ============================================================
# appimg - AppImage manager tool
# Commands:
#   appimg ls
#   appimg move [--all] [-s dir] [file.AppImage]
#   appimg update
#   appimg setup-all
#   appimg reset
#   appimg version
#   appimg help
# ============================================================

VERSION="0.2.0"
APPIMG_DIR="$HOME/.appimages"
DESKTOP_TARGET="${XDG_DATA_HOME:-$HOME/.local/share}/applications"

# Ensure ~/.local/share/applications exists
mkdir -p "$DESKTOP_TARGET"


# ------------------------------------------------------------
# Helpers
# ------------------------------------------------------------
die() {
    echo "Error: $1" >&2
    exit 1
}

find_appimages() {
    local search_dir="$1"
    find "$search_dir" -type f -iname "*.AppImage" 2>/dev/null
}

appname_from_path() {
    basename "$1" | sed -E 's/\.AppImage$//i'
}


# ------------------------------------------------------------
# Command: appimg ls
# ------------------------------------------------------------
cmd_ls() {
    local search="$HOME"
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            *) die "Unknown option for ls: $1" ;;
        esac
    done

    find_appimages "$search"
}


# ------------------------------------------------------------
# Command: appimg move
# ------------------------------------------------------------
cmd_move() {
    local search="$HOME"
    local do_all=0
    local specific_file=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s) search="$2"; shift 2 ;;
            --all) do_all=1; shift ;;
            *) specific_file="$1"; shift ;;
        esac
    done

    mkdir -p "$APPIMG_DIR/managed"
    mkdir -p "$APPIMG_DIR/unmanaged"

    move_one_file() {
        local f="$1"
        if [[ "$f" == "$APPIMG_DIR/managed"* ]]; then
            echo "Skipping (already managed): $f"
            return
        fi

        local tmpdir
        tmpdir=$(mktemp -d)
        chmod +x "$f"
        (cd "$tmpdir" && "$f" --appimage-extract '*.desktop') >/dev/null 2>&1 || true

        local desktop_file
        
        # Check if squashfs-root was created and contains the desktop file
        if [[ ! -d "$tmpdir/squashfs-root" ]]; then
            # If not, try a full extract as a fallback
            (cd "$tmpdir" && "$f" --appimage-extract) >/dev/null 2>&1 || true
        fi
        
        if [[ ! -d "$tmpdir/squashfs-root" ]]; then
            echo "Warning: Failed to extract squashfs-root for $f. Skipping."
            rm -rf "$tmpdir"
            return
        fi

        local all_desktop_files
        all_desktop_files=$(ls -1 "$tmpdir/squashfs-root" | grep ".desktop$")
        
        local desktop_file
        desktop_file=$(echo "$all_desktop_files" | grep -v "url-handler.desktop" | head -n 1)

        if [[ -z "$desktop_file" ]]; then
            desktop_file=$(echo "$all_desktop_files" | head -n 1)
        fi

        if [[ -z "$desktop_file" ]]; then
            echo "Warning: No .desktop file found in $f. Skipping."
            rm -rf "$tmpdir"
            return
        fi

        local desktop_id
        desktop_id=$(basename "$desktop_file" .desktop)
        local dest_dir="$APPIMG_DIR/managed/$desktop_id"
        local dest_appimage="$dest_dir/$desktop_id.AppImage"

        echo "Desktop ID: $desktop_id"
        mkdir -p "$dest_dir"

        echo "Moving $f → $dest_appimage"
        mv "$f" "$dest_appimage" || die "Failed to move $f"
        
        rm -rf "$tmpdir"
    }

    if [[ "$do_all" -eq 1 ]]; then
        mapfile -t files < <(find_appimages "$search")
        [[ ${#files[@]} -eq 0 ]] && die "No AppImages found."

        for f in "${files[@]}"; do
            move_one_file "$f"
        done
        return
    fi

    if [[ -z "$specific_file" ]]; then
        die "You must provide a file unless using --all"
    fi

    if [[ ! -f "$specific_file" ]]; then
        die "File not found: $specific_file"
    fi

    move_one_file "$specific_file"
}

# ------------------------------------------------------------
# Command: appimg update
# ------------------------------------------------------------
cmd_update() {
    local target_app_name=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -*) die "Unknown option for update: $1" ;;
            *)
                if [[ -n "$target_app_name" ]]; then
                    die "update command only accepts one app name argument."
                fi
                target_app_name="$1"
                shift
                ;;
        esac
    done

    [[ ! -d "$APPIMG_DIR" ]] && die "$APPIMG_DIR does not exist."

    local dirs_to_update
    if [[ -n "$target_app_name" ]]; then
        local target_dir="$APPIMG_DIR/managed/$target_app_name"
        if [[ ! -d "$target_dir" ]]; then
            die "Application '$target_app_name' not found."
        fi
        dirs_to_update=("$target_dir")
    else
        dirs_to_update=("$APPIMG_DIR/managed"/*)
    fi

    for dir in "${dirs_to_update[@]}"; do
        [[ ! -d "$dir" ]] && continue
        local name
        name=$(basename "$dir")

        # The main appimage is the symlink if it exists
        local appimage="$dir/$name.AppImage"
        
        # Fallback to first found if no symlink (for unversioned apps)
        if [[ ! -e "$appimage" ]]; then
            appimage=$(find "$dir" -maxdepth 1 -type f -iname "*.AppImage" | head -n 1)
        fi
        
        [[ -z "$appimage" ]] && continue

        # The executable is the real file
        local executable_appimage
        executable_appimage=$(readlink -f "$appimage")
        
        chmod +x "$executable_appimage"
        
        local app_name_for_desktop
        app_name_for_desktop=$(basename "$dir")
        local desktop_file="$dir/$app_name_for_desktop.desktop"


        local name_from_desktop_file=""
        local icon=""
        local terminal_from_desktop=""
        local categories_from_desktop=""

        # Always attempt to extract icons since we need the embedded .desktop file info
        tmpdir=$(mktemp -d)
        
        # Define glob patterns for targeted extraction
        local glob_patterns=(
            '*.desktop'
            'usr/share/applications/*.desktop'
            'share/applications/*.desktop'
            'usr/share/icons/**/*'
            'share/icons/**/*'
            'usr/share/pixmaps/*'
            'share/pixmaps/*'
            '*.png'
            '*.svg'
            '**/*.ico'
        )

        # Perform targeted extraction for each glob pattern
        local extracted_successfully=false
        for pattern in "${glob_patterns[@]}"; do
            (cd "$tmpdir" && "$executable_appimage" --appimage-extract "$pattern") >/dev/null 2>&1 || true
            if [[ -d "$tmpdir/squashfs-root" ]]; then
                extracted_successfully=true
            fi
        done
        
        # If the above fails to create squashfs-root or get files, perform a full extract as fallback
        if [[ "$extracted_successfully" == "false" ]]; then
            echo "Warning: Targeted extraction failed, falling back to full extraction for $executable_appimage." >&2
            (cd "$tmpdir" && "$executable_appimage" --appimage-extract >/dev/null 2>&1) || true
        fi

        if [[ ! -d "$tmpdir/squashfs-root" ]]; then
            echo "Warning: Failed to extract squashfs-root for $executable_appimage. Skipping." >&2
            rm -rf "$tmpdir"
            continue # Move to next AppImage in the loop
        fi

        local icon_name=""
        local desktop_name=""

        if [[ -d "$tmpdir/squashfs-root" ]]; then
            # Try to pick the correct icon by reading the embedded .desktop file's Icon key
            desktop_inside=$(find "$tmpdir/squashfs-root" -type f -iname "*.desktop" | head -n 1)
            if [[ -n "$desktop_inside" ]]; then
                icon_name=$(grep -Ei '^Icon=' "$desktop_inside" | head -n1 | sed -E 's/Icon=//I') || true
                icon_name="${icon_name%%$'\r'}"

                desktop_name=$(grep -Ei '^Name=' "$desktop_inside" | head -n1 | sed -E 's/Name=//I') || true
                desktop_name="${desktop_name%%$'\r'}"
                if [[ -n "$desktop_name" ]]; then
                    name_from_desktop_file="$desktop_name"
                fi

                terminal_from_desktop=$(grep -Ei '^Terminal=' "$desktop_inside" | head -n1 | sed -E 's/Terminal=//I') || true
                terminal_from_desktop="${terminal_from_desktop%%$'\r'}"
                categories_from_desktop=$(grep -Ei '^Categories=' "$desktop_inside" | head -n1 | sed -E 's/Categories=//I') || true
                categories_from_desktop="${categories_from_desktop%%$'\r'}"
            fi

            icon=$(find "$dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
            if [[ -z "$icon" ]]; then

                # Search for SVG first in common icon directories
                icon_candidate=""
                if [[ -n "$icon_name" ]]; then
                    icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.svg" -o -iname "${icon_name,,}.svg" -o -iname "${icon_name^^}.svg" \) | head -n 1 || true)
                fi

                # If no SVG or specific icon, try PNG in same dirs, pick largest
                if [[ -z "$icon_candidate" ]]; then
                    mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.png" -o -iname "${icon_name,,}.png" -o -iname "${icon_name^^}.png" \))
                    best_png=""
                    best_size=0
                    for ic in "${png_candidates[@]}"; do
                        size=$(stat -c %s "$ic" 2>/dev/null)
                        if (( size > best_size )); then
                            best_size=$size
                            best_png="$ic"
                        fi
                    done
                    icon_candidate="$best_png"
                fi

                # If still not found, try XPM
                if [[ -z "$icon_candidate" ]]; then
                    icon_candidate=$(find "$tmpdir/squashfs-root" \( -path "*/usr/share/icons/*" -o -path "*/usr/share/pixmaps/*" -o -path "*/share/icons/*" -o -path "*/share/pixmaps/*" -o -path "*" \) -type f \( -iname "$icon_name.xpm" -o -iname "${icon_name,,}.xpm" -o -iname "${icon_name^^}.xpm" \) | head -n 1 || true)
                fi

                # Fallback: pick the best SVG, else largest PNG, else largest XPM if no specific icon found
                if [[ -z "$icon_candidate" ]]; then
                    # Prefer SVG
                    mapfile -t svg_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.svg' -not -iname '*thumbnail*')
                    if [[ ${#svg_candidates[@]} -gt 0 ]]; then
                        # Pick largest SVG
                        best_svg=""
                        best_size=0
                        for ic in "${svg_candidates[@]}"; do
                            size=$(stat -c %s "$ic" 2>/dev/null)
                            if (( size > best_size )); then
                                best_size=$size
                                best_svg="$ic"
                            fi
                        done
                        icon_candidate="$best_svg"
                    else
                        # Pick largest PNG
                        mapfile -t png_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.png' -not -iname '*thumbnail*')
                        best_png=""
                        best_size=0
                        for ic in "${png_candidates[@]}"; do
                            size=$(stat -c %s "$ic" 2>/dev/null)
                            if (( size > best_size )); then
                                best_size=$size
                                best_png="$ic"
                            fi
                        done
                        icon_candidate="$best_png"
                        # If still not found, pick largest XPM
                        if [[ -z "$icon_candidate" ]]; then
                            mapfile -t xpm_candidates < <(find "$tmpdir/squashfs-root" -type f -iname '*.xpm' -not -iname '*thumbnail*')
                            best_xpm=""
                            best_size=0
                            for ic in "${xpm_candidates[@]}"; do
                                size=$(stat -c %s "$ic" 2>/dev/null)
                                if (( size > best_size )); then
                                    best_size=$size
                                    best_xpm="$ic"
                                fi
                            done
                            icon_candidate="$best_xpm"
                        fi
                    fi
                fi

                if [[ -n "$icon_candidate" ]]; then
                    ext="${icon_candidate##*.}"
                    cp "$icon_candidate" "$dir/icon.$ext" 2>/dev/null || true
                    icon="$dir/icon.$ext"
                    # Create .noiconkeep marker file
                    touch "$dir/.noiconkeep"
                fi
            fi
            rm -rf "$tmpdir"
        fi

        if [[ -z "$icon" ]]; then
            icon=$(find "$dir" -maxdepth 1 -type f -iname "icon.*" | head -n 1)
        fi
        if [[ -z "$icon" ]]; then
            icon="$APPIMG_DIR/placeholder-icon.png"
        fi

        # Use name from .desktop file if available, otherwise fallback to directory name
        local app_name_for_desktop_entry="${name_from_desktop_file:-$app_name_for_desktop}"
        local terminal_for_desktop_entry="${terminal_from_desktop:-false}"
        local categories_for_desktop_entry="${categories_from_desktop:-Utility;}"

        echo "Generating $desktop_file"

        cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=$app_name_for_desktop_entry
Exec="$appimage"
Icon=$icon
Terminal=$terminal_for_desktop_entry
Categories=$categories_for_desktop_entry
EOF

        chmod +x "$desktop_file"

        # Symlink into applications directory
        ln -sf "$desktop_file" "$DESKTOP_TARGET/$app_name_for_desktop.desktop"
        echo "Linked → $DESKTOP_TARGET/$app_name_for_desktop.desktop"
    done
}


# ------------------------------------------------------------
# Command: appimg setup-all
# ------------------------------------------------------------
cmd_setup_all() {
    cmd_move --all
    cmd_update
}


# ------------------------------------------------------------
# Command: appimg reset
# ------------------------------------------------------------
cmd_reset() {
    echo "Resetting AppImage structure..."

    # ---------------------------------------------
    # 1. Remove all .desktop symlinks pointing to ~/.appimages
    # ---------------------------------------------
    echo "Removing AppImage desktop entry symlinks..."
    find "$DESKTOP_TARGET" -type l | while IFS= read -r link; do
        target="$(readlink -f "$link")"
        if [[ "$target" == "$APPIMG_DIR"* ]]; then
            echo "Deleting symlink: $link"
            rm -f "$link"
        fi
    done

    # ---------------------------------------------
    # 2. Move all AppImage files from managed/ to unmanaged/
    # ---------------------------------------------
    echo "Moving managed AppImages to unmanaged..."
    find "$APPIMG_DIR/managed" -type f -iname "*.AppImage" | while IFS= read -r f; do
        file_name=$(basename "$f")
        echo "Moving $f → $APPIMG_DIR/unmanaged/$file_name"
        mv "$f" "$APPIMG_DIR/unmanaged/$file_name" || continue
    done

    # ---------------------------------------------
    # 3. Delete all managed folders
    # ---------------------------------------------
    echo "Deleting managed AppImage directories..."
    find "$APPIMG_DIR/managed" -mindepth 1 -type d -exec rm -rf {} + 2>/dev/null || true

}

# ------------------------------------------------------------
# Command: appimg help
# ------------------------------------------------------------
cmd_help() {
    echo "AppImage manager"
    echo "Commands:"
    echo "  appimg ls [-s dir]"
    echo "  appimg move [--all] [-s dir] [file.AppImage]"
    echo "  appimg update [APPNAME]"
    echo "  appimg setup-all"
    echo "  appimg reset"
    echo "  appimg version"
    echo "  appimg -v"
    echo "  appimg help"
}


# ------------------------------------------------------------
# Command: appimg version
# ------------------------------------------------------------
cmd_version() {
    echo "appimg version $VERSION"
}


# ------------------------------------------------------------
# Dispatcher
# ------------------------------------------------------------
main() {
    case "$1" in
        ls)        shift; cmd_ls "$@" ;;
        move)      shift; cmd_move "$@" ;;
        update)    shift; cmd_update "$@" ;;
        setup-all) shift; cmd_setup_all "$@" ;;
        reset)     shift; cmd_reset ;;
        version|-v) shift; cmd_version "$@" ;;
        help)      shift; cmd_help ;;
        version)   shift; cmd_version ;;
        *)
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
